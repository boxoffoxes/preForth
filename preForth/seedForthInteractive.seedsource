\ seedForth interactive system
\
\ tokenize with
\
\ gforth seedForth-tokinzer.fs seedForthInteractive.seedsource
\
\ then pipe into seedForth:
\
\ cat seedForthInteractive.seed | ./seedForth
\

PROGRAM seedForthInteractive.seed

\ Defining words
Definer Create ( <name> -- )      create ;
Definer Variable ( <name> -- )    create 0 , ;
Definer Constant ( x <name> -- )  create , does> @ ;

\ Missing primitives
: over ( x1 x2 -- x1 x2 x1 )  
    >r dup r> swap ;

: rot ( a b c -- b c a )  
    >r swap r> swap ;

: /string ( x1 x2 x3 -- x4 x5 )   
    swap over - >r + r> ;

: 2drop ( x1 x2 -- )  
    drop drop ;

: 2dup ( x1 x2 -- x1 x2 x1 x2 )  
    over over ;

: 1+ ( x1 -- x2 )  
    1 + ;

: 1- ( x1 -- x2 )  
    1 - ;

: nip ( x1 x2 -- x2 ) 
    swap drop ;

: count ( addr -- c-addr u )  
    dup 1+ swap c@ ;

: < ( n1 n2 -- f )  
    - 0< ;

: > ( n1 n2 -- f )  
    swap < ;

: = ( x1 x2 -- f )  
    - 0= ;

: 0<> ( x -- f ) 
    0= 0= ;

: 2* ( x1 -- x2 )  
    dup + ;

: cell+ ( addr1 -- addr2 ) 
    1 cells + ;

: 2@ ( addr -- x1 x2 ) 
    dup cell+ @ swap @ ;

: 2! ( x1 x2 addr -- ) 
    swap over ! cell+ ! ;

Definer Field ( offset size <name> -- offset' ) 
    create over , + does> @ + ;

\ output
32 Constant bl

: cr    ( -- ) 
    10 emit ;

: type ( c-addr u -- )
    BEGIN dup WHILE  over c@ emit  1  /string  REPEAT  2drop ;

: space ( -- ) 
    bl emit ;

: spaces ( n -- )
    BEGIN ?dup WHILE space 1 - REPEAT ;

Macro ." ( ccc" -- )
   seed s"
   seed type
end-macro

: .digit ( n -- )  
    '0' + emit ;

: third ( x1 x2 x3 -- x1 x2 x3 x1 )
    >r over r> swap ;

: min ( n1 n2 -- n3 )
    2dup > IF swap THEN drop ;

: max ( n1 n2 -- n3 )
    2dup < IF swap THEN drop ;

: r@ ( -- x )  
    r> r> dup >r swap >r ;

: cmove ( c-addr1 c-addr2 u -- )
    BEGIN
      ?dup
    WHILE
      >r
      over c@ over c!
      1+ swap 1+ swap
      r> 1-
    REPEAT
    2drop ;

: place ( c-addr1 u c-addr2 -- )
    2dup >r >r 1+ swap cmove  r> r> c! ;

Macro Literal
   seed lit
   seed [
   seed ,
   seed ]
end-macro



\ Tester 
: empty-stack ( i*x -- )
    BEGIN depth 0< WHILE  0    REPEAT
    BEGIN depth    WHILE  drop REPEAT ;

Variable actual-depth  ( actual-results )  20 cells allot

: nth-result ( n -- addr )
   cells actual-depth + ;

: error ( i*x c-addr u -- )
   cr  type empty-stack ;

: t{ ( i*x -- )
   '.'  emit empty-stack ;

: -> ( -- )
   depth actual-depth !
   BEGIN depth WHILE  depth nth-result !  REPEAT ;

: }t ( i*x -- )
   depth actual-depth @ - IF  s" wrong number of results" error  exit THEN
   BEGIN depth WHILE  depth nth-result @ - IF  s" incorrect result" error  exit THEN  REPEAT ;

\ Test basics
t{ 10 '*' + ->  52 }t
t{ 0 0< -> 0 }t
t{ 1 0< -> 0 }t
t{ 2 0< -> 0 }t
t{ 1 negate 0< -> -1 }t
t{ 2 negate 0< -> -1 }t
t{ 10 20 30 third -> 10 20 30 10 }t


t{ 3 4 max -> 4 }t
t{ 3 4 min -> 3 }t
t{ -1 4 max -> 4 }t
t{ -1 4 min -> -1 }t




: skip ( c-addr1 u1 c -- c-addr2 u2 )
   BEGIN
     over
   WHILE
     >r over c@ r> swap over =
   WHILE
     >r  1 /string  r> 
   REPEAT THEN drop ;

: scan ( c-addr u1 c -- c-addr2 u2 )
   BEGIN
     over
   WHILE
     >r over c@ r> swap over -
   WHILE
     >r  1 /string  r>
   REPEAT THEN drop ;

\ hex number output

: .hexdigit ( n -- )  
    dup 9 > IF lit [ 'A' 10 - , ] ELSE '0' THEN + emit ;

\ if we don't have u2/ but only 2* and 0< we need to implement u2/ with a loop. Candidate for primitive
: u2/ ( x1 -- x2 )
    0 8 cells 1-  BEGIN ?dup WHILE  >r 2*  over 0< IF 1+ THEN  >r 2* r> r> 1- REPEAT nip ;

: odd? ( x1 -- f )  
    dup u2/ 2* = 0= ;

: 2/mod ( x1 -- x2 r )  \ swapped results
    dup u2/ swap odd? negate ;

: 16/mod ( x -- x r )  \ swapped results
    2/mod >r  2/mod >r  2/mod >r  2/mod  2* r> + 2* r> + 2* r> + ;

: #### ( x -- )
    16/mod >r 16/mod >r 16/mod >r  16/mod >r  16/mod >r  16/mod >r 16/mod >r
       .hexdigit  r> .hexdigit   r> .hexdigit  r> .hexdigit  r> .hexdigit
    r> .hexdigit  r> .hexdigit   r> .hexdigit  space ;

: (.) ( x -- )
    ?dup IF  16/mod >r (.) r> .hexdigit THEN ;

: hex-u. ( x -- )
    ?dup IF (.) ELSE '0' emit THEN space ;

: hex. ( n -- )  
    dup 0< IF '-' emit negate THEN hex-u. ;


\ decimal output
\ --------------

: (/mod  ( n d q0 -- r d q )
    >r 2dup <  r> swap ?exit
    >r swap over -  swap  r> 1+  (/mod ;

: 10* ( x1 -- x2 )
    dup + dup dup + dup + + ;

: (10u/mod ( n q d -- r q d )
    third over > 0= ?exit     \ ( n q d )
    dup >r 10*                 \ ( n q 10*d ) ( R: d )
    (10u/mod                   \ ( r q d )
    swap >r   0 (/mod nip   r> 10* + r> ;
     
: 10u/mod ( n -- r q )
    0 1 (10u/mod drop  ;

: (u. ( u1 -- )
    ?dup IF 10u/mod (u. .digit THEN ;

\ display unsigned number
: u. ( u -- )
    dup (u. 0= IF '0' emit THEN space ;

\ display signed number
: . ( n -- )
    dup 0< IF '-' emit negate THEN u. ;

: .s ( i*x -- i*x )  
    depth 0= ?exit  >r .s r> dup . ;

\ Deferred words

: ' ( --  x )  key ;

: uninitialized ( -- ) 
     cr s" uninitialized execution vector" type -1 throw ;

Definer Defer ( <name> -- ) 
   create [ ' uninitialized ] Literal , does> @ execute ;

: >body ( xt -- body )  
    h@  1 cells + ;

: is ( xt -- )  \ only interactive
    ' >body ! ;

\ String comparison
: compare ( c-addr1 u1 c-addr2 u2 -- n )
    rot 
    BEGIN \ ( c-addr1 c-addr2 u1 u2 )
      over 
    WHILE
      dup
    WHILE
      >r >r  over c@ over c@ - ?dup IF 0< dup + 1  + nip nip r> drop r> drop exit THEN
      1+ swap 1+ swap
      r> 1- r> 1-
    REPEAT
      -1
    ELSE
      dup 0= IF 0  ELSE 1  THEN
    THEN >r 2drop 2drop r> ;

\ Some general memory allocation words

: alloc ( u -- addr )
    here swap allot ;

: dispose ( addr -- )
    drop ;

Create tib 80 allot
Variable #tib

: accept ( c-addr u1 -- u2 )
    >r
    0 BEGIN ( c-addr u2 ) ( R: u1 )
        key dup 10 = over 13 = or 0=
    WHILE ( c-addr u2 key )
        dup  8 = over 127 = or IF  drop 1- 0 max  8 emit bl emit 8 emit ELSE
        ( dup emit ) >r 2dup + r> swap c!  1+ r@ min THEN
    REPEAT ( c-addr u2 key r:u1 )
    drop  r> drop   nip ;

: query ( -- )
    tib 80 accept #tib ! ;

\ Header

0
1 cells Field _link
1       Field _flags
1 cells Field _xt
0       Field _name

Constant #header


Variable last  0 last !

: "header ( c-addr u -- addr )
    \ 2dup lowercase
    dup #header + 1+ alloc >r ( c-addr u r:addr )
    0 r@ _link !
    0 r@ _flags c!
    0 r@ _xt !
    r@ _name place 
    r> ;

: link ( addr -- )  
    last @  swap _link dup last ! ! ;

: @flags ( -- x )  
    last @ _flags c@ ;

: !flags ( x -- )  
    last @ _flags c! ;

128 Constant #immediate

: immediate? ( addr -- f )
    _flags @ #immediate and 0<> ;

: immediate ( -- )
    @flags  #immediate or  !flags ;

: pad ( -- addr )
   here 100 + ;

Variable context

: words ( -- )
   context @ BEGIN ?dup WHILE dup _name count type space @ REPEAT ;

: hide ( -- )  
    last @ @ context ! ;

: reveal ( -- ) 
    last @ context ! ;

reveal

: !chars ( S addr -- addr' )
    over 0= IF nip exit THEN
    rot >r  swap 1- swap !chars
    r> over c! 1+ ;

: !str ( S addr -- )
    2dup c! 1+ !chars drop ;

Macro has-header ( <name> -- )
   seed $name 
   seed pad 
   seed !str 
   seed pad 
   seed count
   seed "header
   seed dup
   seed link
   seed _xt
   seed !
end-macro


' bye         has-header bye         \ 0   00
' emit        has-header emit        \ 1   01
' key         has-header key         \ 2   02
' dup         has-header dup         \ 3   03
' swap        has-header swap        \ 4   04
' drop        has-header drop        \ 5   05
' 0<          has-header 0<          \ 6   06
' ?exit       has-header ?exit       \ 7   07
' >r          has-header >r          \ 8   08
' r>          has-header r>          \ 9   09
' -           has-header -           \ 10  0A
' exit        has-header exit        \ 11  0B
' lit         has-header lit         \ 12  0C
' @           has-header @           \ 13  0D
' c@          has-header c@          \ 14  0E
' !           has-header !           \ 15  0F
' c!          has-header c!          \ 16  10
' execute     has-header execute     \ 17  11
' branch      has-header branch      \ 18  12
' ?branch     has-header ?branch     \ 19  13
' negate      has-header negate      \ 20  14
' +           has-header +           \ 21  15
' 0=          has-header 0=          \ 22  16
' ?dup        has-header ?dup        \ 23  17
' cells       has-header cells       \ 24  18
' +!          has-header +!          \ 25  19
' h@          has-header h@          \ 26  1A
' h,          has-header h,          \ 27  1B
' here        has-header here        \ 28  1C
' allot       has-header allot       \ 29  1D
' ,           has-header ,           \ 30  1E
' c,          has-header c,          \ 31  1F
' fun         has-header fun         \ 32  20
' interpreter has-header interpreter \ 33  21
' compiler    has-header compiler    \ 34  22
' create      has-header create      \ 35  23
' does>       has-header does>       \ 36  24
' cold        has-header cold        \ 37  25
' depth       has-header depth       \ 38  26
' compile,    has-header compile,    \ 39  26
' new         has-header new         \ 40  28
' couple      has-header couple      \ 41  29
' and         has-header and         \ 42  2A
' or          has-header or          \ 43  2B
' catch       has-header catch       \ 44  2C
' throw       has-header throw       \ 45  2D
' sp@         has-header sp@         \ 46  2E
' sp!         has-header sp!         \ 47  2F
' rp@         has-header rp@         \ 48  30
' rp!         has-header rp!         \ 49  31
' $lit        has-header $lit        \ 50  32
' num         has-header num         \ 51  33

' over        has-header over      
' /string     has-header /string   
' type        has-header type      
' 2dup        has-header 2dup      
' cr          has-header cr        
' .s          has-header .s        
' t{          has-header t{        
' ->          has-header ->        
' }t          has-header }t        

' space       has-header space     
' spaces      has-header spaces    

' 1+          has-header 1+        
' 1-          has-header 1-        
' nip         has-header nip       
' <           has-header <         
' >           has-header >         
' =           has-header =         
' count       has-header count     
' 2*          has-header 2*        

' cmove       has-header cmove     
' cell+       has-header cell+     
' place       has-header place     
' compare     has-header compare   
' 2@          has-header 2@        
' 2!          has-header 2!        

' skip        has-header skip      
' scan        has-header scan 
' .           has-header .         
' words       has-header words 
' immediate   has-header immediate
' pad         has-header pad  




Macro :noname
   seed new
   seed compiler
end-macro

\ :noname 10 ; 


: (IF)  ( -- c:orig )
     [ ' ?branch ] Literal compile,  here 0 , ;

: (AHEAD)  ( -- c:orig )
     [ ' branch ] Literal compile,  here 0 , ;

: (THEN) ( c:orig -- )
     here swap ! ;

: (ELSE) ( c:orig1 -- c:orig2 )
     [ ' branch ] Literal compile,  here 0 ,  swap (THEN) ;

: (WHILE) ( c: orig -- c:dest c:orig )
     (IF) swap ;

: (AGAIN) ( c:orig -- )
     [ ' branch ] Literal compile, , ;

: (UNTIL)
     [ ' ?branch ] Literal compile, , ;

: (REPEAT)
     (AGAIN) (THEN) ;

' (IF)        has-header IF immediate
' (ELSE)      has-header ELSE immediate
' (THEN)      has-header THEN immediate
' (AHEAD)     has-header AHEAD immediate

' here        has-header BEGIN immediate
' (WHILE)     has-header WHILE immediate
' (AGAIN)     has-header AGAIN immediate
' (UNTIL)     has-header UNTIL immediate
' (REPEAT)    has-header REPEAT immediate


Variable >in ( -- addr )

: source ( -- c-addr u )
   tib   #tib @ ;

: parse ( c -- c-addr u )
   >r source >in @ /string
   2dup r> dup >r  scan
   2dup r> skip  nip source nip swap - >in !
   nip - ;

: parse-name ( -- c-addr u )
   source >in @ /string
   bl skip  2dup bl scan  source nip  2dup swap - 1+ min >in !    nip - ;

' parse        has-header parse     
' parse-name   has-header parse-name 


: (Literal) ( x -- )
    lit [ ' lit , ] compile, , ;

' (Literal)   has-header Literal  immediate

: (.") ( ccc" -- )
    [ ' $lit ] Literal compile,  
    '"' parse here over 1+ allot place 
    [ ' type ] Literal compile, ;

' (.") has-header ." immediate


\ : (Create) ( <name> -- )
\      Header create  hp@ swap _xt ! 0 , ;  
\ ' (Create)   has-header Create

: find-name ( c-addr u link -- header|0 )
    \ >r 2dup lowercase r>
    BEGIN ( c-addr u link )
      dup
    WHILE ( c-addr u link )
      >r  2dup  r> dup >r
      _name count  compare  0= IF 2drop r> exit THEN
      r> @
    REPEAT
    nip nip ;

: tick ( <name> -- xt )
   parse-name last @ find-name dup IF _xt @ exit THEN -13 throw ;

' tick        has-header '

: ([']) ( <name> -- xt )
    tick  [ ' lit ] Literal compile,  , ;

' ([']) has-header ['] immediate


: digit? ( c -- f )
    dup '0' < IF drop 0 exit THEN '9' > 0= ;

: ?# ( c-addr u -- x 0 0 | c-addr u )
    dup 0= ?exit
    over c@ '-' = dup >r IF  1 /string THEN 
    2dup 0 >r
    BEGIN
      dup
    WHILE
      over c@ dup digit? 0= IF drop r> drop r> drop 2drop exit THEN
      '0' - r> 10*  + >r
      1 /string
    REPEAT
    2drop 2drop r>  r> IF negate THEN 0 0 ;

: ,# ( c-addr u -- 0 0 | c-addr u )
    dup 0= ?exit
    ?# dup ?exit
    lit [ ' lit , ] compile, rot , ;

:  ?'x' ( c-addr u -- x 0 0 | c-addr u )
    dup 0= ?exit
    dup 3 =
    IF over c@     ''' - ?exit
       over 2 + c@ ''' - ?exit
       drop 1+ c@ 0 0 THEN ;

: ,'x' ( c-addr u -- 0 0 | c-addr u )
    dup 0= ?exit
    ?'x' dup ?exit
    lit [ ' lit , ] compile, rot , ;


: ?word ( c-addr1 u1 | i*x c-addr2 u2 )
   dup 0= ?exit
   2dup context @ find-name ?dup IF nip nip _xt @ execute 0 0 THEN
;

: (interpreters ( c-addr1 u1 | i*x c-addr2 u2 )
   ?word
   ?#
   ?'x'
   over IF space type '?' emit  space -13 throw THEN 
;

: ,word ( c-addr1 u1 | i*x c-addr2 u2 )
   dup 0= ?exit
   2dup context @ find-name ?dup
   IF nip nip dup immediate? IF _xt @ execute ELSE _xt @ compile, THEN 0 0 THEN
;

: (compilers ( c-addr u1 | i*x c-addr2 u2 )
    ,word
    ,#
    ,'x'
    over IF space type '?' emit  space -13 throw THEN 
;

Variable compilers       ' (compilers compilers !
Variable interpreters    ' (interpreters interpreters !
Variable handlers        interpreters @ handlers !

: (]) ( -- )
   compilers @ handlers ! ;

: ([)
   interpreters @ handlers ! ;

: Header ( <name> -- addr )
    parse-name "header dup link reveal ;

: (:) ( <name> -- )
    Header new swap _xt ! hide  (]) ;

: (;) ( -- )
   lit [ ' exit , ] compile,  reveal ([) ;

' (])   has-header ] 
' ([)   has-header [  immediate 
' (;)   has-header ;  immediate
' (:)   has-header : 


: interpret ( -- )
   BEGIN ( )
      parse-name dup
   WHILE ( c-addr u )
      handlers @ execute 2drop  
   REPEAT 
   2drop ;

: prompt ( -- )
    cr .s handlers @ compilers @ = IF ']' ELSE '>' THEN emit space ;

: .ok ( -- ) ."  ok" ;

: restart ( -- )
   ([)
   BEGIN
     prompt query  0 >in !  interpret  .ok
   0 UNTIL ;

: warm ( -- )
   \ [ ' [ compile, ] 
   empty-stack restart ;



2 Constant major ( -- x )
0 Constant minor ( -- x )
1 Constant patch ( -- x )

: .version ( -- )
    major .digit '.' emit
    minor .digit '.' emit
    patch .digit ;

: .banner ( -- )
    cr ." seedForth " .version
    cr ." ---------------" cr ;

: boot ( -- )
   key drop \ skip 0 of boot program
   .banner
   words cr
   BEGIN
      [ ' warm ] Literal catch ?dup IF ." error " . cr THEN
   AGAIN ;

reveal
boot
END
